================================================================================
DIGITAL HAND HOLDING - DEBUG FILES DUMP
================================================================================
Дата: 2026-02-16
Проблема: Кнопка "Create Room" не работает, console.log не появляются вообще
Симптомы:
- Консоль браузера полностью пустая (ни одного лога)
- Network: main.ts загружается (200 OK)
- Нет WebSocket соединений
- Нет ошибок JavaScript

================================================================================
=== client/index.html ===
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Digital Hand Holding - Connect with Someone Special</title>
  <style>
    /* ... стили опущены для краткости ... */
  </style>
</head>
<body>
  <div id="app">
    <!-- Landing Screen -->
    <div id="landingScreen" class="screen">
      <div style="font-size: 3rem; color: #ff00ff;">1</div>
      <h1>DIGITAL HAND HOLDING</h1>
      <p>Connect with someone special in a virtual space</p>
      <button id="createRoomBtn" class="btn">CREATE ROOM</button>
      <div style="margin-top: 20px;">
        <input type="text" id="roomIdInput" placeholder="Enter Room ID">
        <button id="joinRoomBtn" class="btn">JOIN ROOM</button>
      </div>
    </div>

    <!-- Game Screen -->
    <div id="gameScreen" class="screen hidden">
      <div id="canvasContainer"></div>
      <div class="corner-circle top-left"></div>
      <div class="corner-circle top-right"></div>
      <div class="corner-circle bottom-left"></div>
      <div class="corner-circle bottom-right"></div>
      <button id="leftMenuBtn" class="btn">☰</button>
      <button id="menuBtn" class="btn">☰</button>
      <div id="centerPanel">
        <div id="centerRoomId">
          <span>Room ID: </span>
          <span id="currentRoomId" class="copyable-id"></span>
        </div>
        <div id="chat-container">
          <div id="chat-messages"></div>
          <div id="chat-input-container">
            <input type="text" id="chat-input" placeholder="Type your message...">
            <button id="chat-send-btn">Send</button>
          </div>
        </div>
      </div>
      <!-- Sidebars omitted for brevity -->
    </div>
  </div>

  <!-- DEBUG: Проверка загрузки скрипта -->
  <script>
    console.log('=== HTML LOADED ===');
    console.log('window.addEventListener load will fire now...');
  </script>

  <script type="module" src="/src/main.ts"></script>
</body>
</html>
=== конец файла ===

================================================================================
=== client/src/main.ts ===
import { GameEngine } from './core/GameEngine';
import { NetworkManager } from './core/NetworkManager';
import { InputManager } from './core/InputManager';
import { UIController } from './ui/UIController';
import { ChatManager } from './chat/ChatManager';

// === DEBUG: main.ts загружен ===
console.log('=== MAIN.TS LOADED ===');
console.log('window.addEventListener load registering...');

class MainApp {
  private gameEngine: GameEngine;
  private networkManager: NetworkManager;
  private inputManager: InputManager;
  private uiController: UIController;
  private chatManager: ChatManager;

  constructor() {
    console.log('[MainApp] Constructor started...');
    console.log('[MainApp] Creating GameEngine...');
    this.gameEngine = new GameEngine('canvasContainer');
    console.log('[MainApp] Creating NetworkManager...');
    this.networkManager = new NetworkManager();
    console.log('[MainApp] Creating InputManager...');
    this.inputManager = new InputManager();
    console.log('[MainApp] Creating UIController...');
    this.uiController = new UIController();
    console.log('[MainApp] Creating ChatManager...');
    this.chatManager = new ChatManager();
    console.log('[MainApp] Setting up interactions...');
    this.setupInteractions();
    console.log('[MainApp] Starting game engine...');
    this.gameEngine.start();
    console.log('[MainApp] Constructor finished!');
  }

  getInputManager(): InputManager {
    return this.inputManager;
  }

  private setupInteractions(): void {
    console.log('[MainApp] Setting up interactions...');
    this.uiController.onCreateRoom = async () => {
      console.log('[MainApp] onCreateRoom called!');
      try {
        console.log('[MainApp] Calling networkManager.createRoom()...');
        const roomId = await this.networkManager.createRoom();
        console.log('[MainApp] Room created with ID:', roomId);
        this.uiController.setView('room');
        const room = this.networkManager.getCurrentRoom();
        if (room) {
          this.chatManager.attachToRoom(room);
          this.uiController.updateRoomIdFromRoom(room);
        }
        this.uiController.setPlayerName('Player 1');
        this.setupRoomStateListener();
      } catch (error) {
        console.error('[MainApp] ERROR in onCreateRoom:', error);
        alert('Failed to create room. Please try again.');
      }
    };

    this.uiController.onJoinRoom = async (roomId) => {
      console.log('[MainApp] onJoinRoom called with roomId:', roomId);
      try {
        await this.networkManager.joinRoom(roomId);
        this.uiController.setView('room');
        const room = this.networkManager.getCurrentRoom();
        if (room) {
          this.chatManager.attachToRoom(room);
          this.uiController.updateRoomIdFromRoom(room);
        }
        this.uiController.setPlayerName('Player 2');
        this.setupRoomStateListener();
      } catch (error) {
        console.error('[MainApp] ERROR in onJoinRoom:', error);
        alert('Failed to join room.');
      }
    };
  }

  private setupRoomStateListener(): void {
    this.networkManager.onStateChange((state) => {
      if (state && state.players) {
        this.uiController.updatePlayerCount(state.players.size);
      }
    });
    const initialState = this.networkManager.getState();
    if (initialState && initialState.players) {
      this.uiController.updatePlayerCount(initialState.players.size);
    }
  }
}

// Запуск приложения при загрузке страницы
console.log('window.addEventListener("load") registering callback...');
window.addEventListener('load', () => {
  console.log('=== LOAD EVENT FIRED ===');
  console.log('Creating new MainApp()...');
  new MainApp();
  console.log('MainApp() created!');
});
console.log('window.addEventListener("load") callback registered');
=== конец файла ===

================================================================================
=== client/src/core/NetworkManager.ts ===
import { Client } from 'colyseus.js';
import { Room } from 'colyseus.js';

export class NetworkManager {
  private client: Client;
  private currentRoom: Room | null = null;
  private readonly serverUrl: string;

  constructor(serverUrl?: string) {
    // HARDCODE: для теста используем прод-сервер
    this.serverUrl = serverUrl || 'wss://cursor-hold-game-server.onrender.com';
    this.client = new Client(this.serverUrl);
    console.log('[NetworkManager] Server URL:', this.serverUrl);
  }

  async createRoom(): Promise<string> {
    console.log('[NetworkManager] createRoom() called');
    console.log('[NetworkManager] Current client:', this.client);
    try {
      console.log('[NetworkManager] Calling client.joinOrCreate("holding_room")...');
      this.currentRoom = await this.client.joinOrCreate('holding_room');
      console.log('[NetworkManager] Room object received:', this.currentRoom);
      const roomId = this.currentRoom.state?.roomId || this.currentRoom.id;
      console.log('[NetworkManager] Room created:', roomId);
      return roomId;
    } catch (error) {
      console.error('[NetworkManager] ERROR in createRoom:', error);
      throw error;
    }
  }

  async joinRoom(roomId: string): Promise<Room> {
    try {
      this.currentRoom = await this.client.joinById(roomId);
      console.log('[NetworkManager] Joined room:', roomId);
      return this.currentRoom;
    } catch (error) {
      console.error('Failed to join room:', error);
      throw error;
    }
  }

  getCurrentRoom(): Room | null {
    return this.currentRoom;
  }

  onStateChange(callback: (state: any) => void): void {
    if (this.currentRoom) {
      this.currentRoom.onStateChange((state) => {
        callback(state);
      });
    }
  }

  getState() {
    if (this.currentRoom) {
      return this.currentRoom.state;
    }
    return null;
  }
}
=== конец файла ===

================================================================================
=== client/src/ui/UIController.ts ===
export class UIController {
  private lobbyContainer: HTMLElement;
  private roomContainer: HTMLElement;
  private createRoomBtn: HTMLButtonElement;
  private joinRoomBtn: HTMLButtonElement;
  private roomIdInput: HTMLInputElement;
  private currentView: 'lobby' | 'room' = 'lobby';
  private leftMenuBtn: HTMLButtonElement;
  private menuBtn: HTMLButtonElement;
  private leftSidebar: HTMLElement;
  private rightSidebar: HTMLElement;
  private closeLeftSidebarBtn: HTMLButtonElement;
  private closeSidebarBtn: HTMLButtonElement;

  constructor() {
    this.lobbyContainer = document.getElementById('landingScreen')!;
    this.roomContainer = document.getElementById('gameScreen')!;
    this.createRoomBtn = document.getElementById('createRoomBtn') as HTMLButtonElement;
    this.joinRoomBtn = document.getElementById('joinRoomBtn') as HTMLButtonElement;
    this.roomIdInput = document.getElementById('roomIdInput') as HTMLInputElement;
    this.leftMenuBtn = document.getElementById('leftMenuBtn') as HTMLButtonElement;
    this.menuBtn = document.getElementById('menuBtn') as HTMLButtonElement;
    this.leftSidebar = document.getElementById('leftSidebar')!;
    this.rightSidebar = document.getElementById('sidebar')!;
    this.closeLeftSidebarBtn = document.getElementById('closeLeftSidebarBtn') as HTMLButtonElement;
    this.closeSidebarBtn = document.getElementById('closeSidebarBtn') as HTMLButtonElement;
    this.setupEventListeners();
    this.setView('lobby');
  }

  private setupEventListeners(): void {
    this.createRoomBtn?.addEventListener('click', () => {
      this.onCreateRoomClick();
    });
    this.joinRoomBtn?.addEventListener('click', () => {
      this.onJoinRoomClick();
    });
    // ... остальные обработчики
  }

  private onCreateRoomClick(): void {
    console.log('[UIController] Create Room button clicked!');
    if (this.onCreateRoom) {
      console.log('[UIController] Calling onCreateRoom callback...');
      this.onCreateRoom();
    } else {
      console.error('[UIController] onCreateRoom callback is NOT set!');
    }
  }

  setView(view: 'lobby' | 'room'): void {
    this.currentView = view;
    if (view === 'lobby') {
      this.lobbyContainer.style.display = 'flex';
      this.roomContainer.style.display = 'none';
    } else {
      this.lobbyContainer.style.display = 'none';
      this.roomContainer.style.display = 'flex';
    }
  }

  updateRoomIdFromRoom(room: any): void {
    const roomId = room?.customRoomId || room?.state?.roomId || 'Unknown';
    this.showCreatedRoomId(roomId);
  }

  // ... остальные методы
  onCreateRoom?: () => void;
  onJoinRoom?: (roomId: string) => void;
}
=== конец файла ===

================================================================================
=== client/src/chat/ChatManager.ts ===
import { Room } from 'colyseus.js';

export class ChatManager {
  private room: Room | null = null;
  private chatContainer: HTMLElement;
  private messageInput: HTMLInputElement;
  private sendMessageBtn: HTMLButtonElement;

  constructor() {
    this.chatContainer = document.getElementById('chat-messages')!;
    this.messageInput = document.getElementById('chat-input') as HTMLInputElement;
    this.sendMessageBtn = document.getElementById('chat-send-btn') as HTMLButtonElement;
    this.setupEventListeners();
  }

  attachToRoom(room: Room): void {
    this.room = room;
    this.room.onMessage('chatMessage', (data) => {
      this.receiveMessage(data.playerName, data.message, data.timestamp);
    });
  }

  sendMessage(): void {
    const message = this.messageInput?.value.trim();
    if (!message || !this.room) return;
    this.room.send('chatMessage', { message, timestamp: Date.now() });
    this.messageInput.value = '';
  }

  private receiveMessage(sender: string, message: string, timestamp: number): void {
    const messageElement = document.createElement('div');
    messageElement.className = 'chat-message';
    const timeString = new Date(timestamp).toLocaleTimeString();
    messageElement.innerHTML = `<strong>${sender}:</strong> ${message}`;
    this.chatContainer.appendChild(messageElement);
    this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
  }
}
=== конец файла ===

================================================================================
=== client/src/core/GameEngine.ts ===
import * as PIXI from 'pixi.js';

export class GameEngine {
  readonly app: PIXI.Application;
  private ticker: PIXI.Ticker;

  constructor(containerId: string = 'canvasContainer') {
    this.app = new PIXI.Application();
    this.ticker = this.app.ticker;
    const container = document.getElementById(containerId);
    if (!container) {
      throw new Error(`Container element with id "${containerId}" not found`);
    }
    this.app.init({
      backgroundColor: 0x1a1a1a,
      width: window.innerWidth,
      height: window.innerHeight,
      antialias: true,
      autoDensity: true,
      resolution: Math.min(window.devicePixelRatio, 2),
    });
    container.appendChild(this.app.canvas);
  }

  start(): void {
    this.ticker.start();
  }
}
=== конец файла ===

================================================================================
=== client/src/core/InputManager.ts ===
export class InputManager {
  private keyboardState: Map<string, boolean>;
  private mouseState: { x: number; y: number; leftButton: boolean; rightButton: boolean };

  constructor() {
    this.keyboardState = new Map();
    this.mouseState = { x: 0, y: 0, leftButton: false, rightButton: false };
    this.setupEventListeners();
  }

  private setupEventListeners(): void {
    window.addEventListener('keydown', (e) => {
      this.keyboardState.set(e.code, true);
    });
    window.addEventListener('keyup', (e) => {
      this.keyboardState.set(e.code, false);
    });
    // ... mouse events
  }
}
=== конец файла ===

================================================================================
=== client/package.json ===
{
  "name": "@holding-hands/client",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "test": "vitest"
  },
  "dependencies": {
    "@pixi/filter-bloom": "^5.1.1",
    "@pixi/filter-crt": "^5.1.1",
    "@pixi/filter-noise": "^5.3.12",
    "@pixi/filter-pixelate": "^5.1.1",
    "colyseus.js": "^0.15.28",
    "pixi.js": "^8.16.0"
  },
  "devDependencies": {
    "@types/jest": "^29.5.0",
    "@types/node": "^20.0.0",
    "@vitest/ui": "^1.0.0",
    "typescript": "^5.0.2",
    "vite": "^5.0.0",
    "vitest": "^1.0.0"
  }
}
=== конец файла ===

================================================================================
=== client/vite.config.ts ===
import { defineConfig } from 'vite';
import { resolve } from 'path';

export default defineConfig({
  server: {
    port: 3000,
    host: true
  },
  build: {
    rollupOptions: {
      input: {
        main: resolve(__dirname, 'index.html'),
      }
    }
  }
});
=== конец файла ===

================================================================================
=== client/tsconfig.json ===
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src", "src/types/**/*.d.ts"]
}
=== конец файла ===

================================================================================
=== client/.env ===
VITE_SERVER_URL=wss://cursor-hold-game-server.onrender.com
=== конец файла ===

================================================================================
=== client/vitest.config.ts ===
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./vitest.setup.ts'],
  },
});
=== конец файла ===

================================================================================
=== client/vitest.setup.ts ===
(Файл существует, содержимое не читалось)
=== конец файла ===

================================================================================
=== package.json (root) ===
{
  "name": "holding-hands-game",
  "version": "1.0.0",
  "scripts": {
    "dev:client": "cd client && npm run dev",
    "dev:server": "cd server && npm run dev",
    "build:client": "cd client && npm run build",
    "build:server": "cd server && npm run build",
    "start": "concurrently \"npm run dev:server\" \"npm run dev:client\"",
    "test": "npm run test --workspaces"
  },
  "workspaces": ["client", "server"],
  "lint-staged": {
    "client/*.{ts,tsx}": ["cd client && npx tsc --noEmit"],
    "server/*.{ts,tsx}": ["cd server && npx tsc --noEmit"]
  }
}
=== конец файла ===

================================================================================
КОНЕЦ ФАЙЛА
================================================================================
