================================================================================
MFL (MOUSE FOLLOWER) SYSTEM - ALL FILES
================================================================================
Ğ”Ğ°Ñ‚Ğ°: 2026-02-17
Ğ’ĞµÑ€ÑĞ¸Ñ: v11
ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ: ĞŸĞ¾Ğ»Ğ½Ğ°Ñ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹ mouse followers (mfl1/mfl2) Ñ trail effects

================================================================================
Ğ¤ĞĞ™Ğ› 1: client/src/features/mouse-follower/MouseFollowerManager.ts
================================================================================

import * as PIXI from 'pixi.js';
import { NetworkManager } from '../../core/NetworkManager';

/**
 * Mouse Follower System (MFL)
 *
 * Each player sees TWO followers in real-time:
 * - mfl1 (RED): Follows Player 1's (creator) mouse
 * - mfl2 (BLUE): Follows Player 2's (joiner) mouse
 *
 * Both players see BOTH followers on their screen.
 */

interface MouseFollowerData {
  playerId: string;           // Server session ID
  label: 'mfl1' | 'mfl2';     // Clear label
  color: number;              // Red for mfl1, Blue for mfl2
  targetX: number;            // Target position (from network)
  targetY: number;
  currentX: number;           // Interpolated position
  currentY: number;
  graphics: PIXI.Container | null;
  labelSprite: PIXI.Text | null;
  trail: TrailParticle[];     // Trail particles behind follower
}

interface TrailParticle {
  x: number;
  y: number;
  alpha: number;
  radius: number;
  graphics: PIXI.Graphics;
}

export class MouseFollowerManager {
  private followers: Map<string, MouseFollowerData> = new Map();
  private localPlayerId: string | null = null;
  private isCreator: boolean = false;
  private lastSendTime: number = 0;
  private readonly SEND_INTERVAL_MS: number = 33; // ~30 updates per second
  private readonly TRAIL_LENGTH: number = 8;      // Number of trail particles
  private readonly TRAIL_SPAWN_RATE: number = 3;  // Spawn trail every N frames
  private frameCount: number = 0;

  constructor(
    private stage: PIXI.Container,
    private networkManager: NetworkManager
  ) {
    // Subscribe to server messages
    this.networkManager.onMessage('mflUpdate', (data: {
      playerId: string;
      isCreator: boolean;
      x: number;
      y: number;
    }) => {
      this.updateRemoteFollower(data.playerId, data.isCreator, data.x, data.y);
    });

    // Start interpolation ticker
    PIXI.Ticker.shared.add((ticker) => this.update(ticker.deltaTime));

    console.log('[MouseFollowerManager] Initialized');
  }

  /**
   * Call when room is joined/created
   */
  onRoomJoined(isCreator: boolean, localPlayerId: string) {
    this.localPlayerId = localPlayerId;
    this.isCreator = isCreator;

    console.log(`[MouseFollowerManager] Room joined - isCreator: ${isCreator}, playerId: ${localPlayerId}`);

    // Create local follower entry (we'll update it every frame)
    const label = isCreator ? 'mfl1' : 'mfl2';
    const color = isCreator ? 0xff0000 : 0x0000ff; // Red for mfl1, Blue for mfl2

    this.followers.set(localPlayerId, {
      playerId: localPlayerId,
      label,
      color,
      targetX: 0,
      targetY: 0,
      currentX: 0,
      currentY: 0,
      graphics: null,
      labelSprite: null,
      trail: [],
    });

    console.log(`[MouseFollowerManager] Created local follower: ${label}`);
  }

  /**
   * Update local mouse position - called every frame from InputManager
   */
  updateLocalPosition(x: number, y: number) {
    if (!this.localPlayerId) return;

    const follower = this.followers.get(this.localPlayerId);
    if (follower) {
      follower.targetX = x;
      follower.targetY = y;

      // Send to server (rate-limited)
      const now = Date.now();
      if (now - this.lastSendTime > this.SEND_INTERVAL_MS) {
        this.networkManager.sendToRoom('mflUpdate', {
          isCreator: this.isCreator,
          x,
          y
        });
        this.lastSendTime = now;
      }
    }
  }

  /**
   * Update remote follower position from server
   */
  private updateRemoteFollower(playerId: string, isCreator: boolean, x: number, y: number) {
    let follower = this.followers.get(playerId);

    if (!follower) {
      // New remote player joined - create follower
      const label = isCreator ? 'mfl1' : 'mfl2';
      const color = isCreator ? 0xff0000 : 0x0000ff;

      follower = {
        playerId,
        label,
        color,
        targetX: x,
        targetY: y,
        currentX: x,
        currentY: y,
        graphics: null,
        labelSprite: null,
        trail: [],
      };

      this.followers.set(playerId, follower);
      console.log(`[MouseFollowerManager] Created remote follower: ${label} (${playerId})`);
    }

    // Update target position
    follower.targetX = x;
    follower.targetY = y;
  }

  /**
   * Create visual representation for a follower
   */
  private createFollowerGraphics(follower: MouseFollowerData) {
    if (follower.graphics) return; // Already created

    const container = new PIXI.Container();

    // Create the follower circle (glowing effect)
    const circle = new PIXI.Graphics();
    circle.beginFill(follower.color, 0.5); // Semi-transparent fill
    circle.drawCircle(0, 0, 20);
    circle.endFill();
    circle.lineStyle(3, follower.color, 1); // Solid color border
    circle.drawCircle(0, 0, 20);

    // Inner glow
    const glow = new PIXI.Graphics();
    glow.beginFill(follower.color, 0.3);
    glow.drawCircle(0, 0, 25);
    glow.endFill();

    // Center dot
    const center = new PIXI.Graphics();
    center.beginFill(0xffffff, 1);
    center.drawCircle(0, 0, 5);
    center.endFill();

    // Create label text
    const labelSprite = new PIXI.Text(follower.label, {
      fontFamily: 'Courier New',
      fontSize: 14,
      fill: follower.color,
      fontWeight: 'bold',
      stroke: {
        color: 0x000000,
        width: 4,
      } as any,
    });
    labelSprite.anchor.set(0.5);
    labelSprite.x = 0;
    labelSprite.y = -35; // Above the circle

    // Assemble container
    container.addChild(glow);
    container.addChild(circle);
    container.addChild(center);
    container.addChild(labelSprite);

    container.zIndex = 1000;

    this.stage.addChild(container);

    follower.graphics = container;
    follower.labelSprite = labelSprite;

    console.log(`[MouseFollowerManager] Created graphics for ${follower.label}`);
  }

  /**
   * Update all followers (interpolation + rendering + trail)
   */
  private update(delta: number) {
    const lerp = 0.2; // Smoother interpolation
    this.frameCount++;

    this.followers.forEach((follower) => {
      if (!follower.graphics) {
        // Create graphics on first update
        this.createFollowerGraphics(follower);
        return;
      }

      // Interpolate position
      follower.currentX += (follower.targetX - follower.currentX) * lerp * delta;
      follower.currentY += (follower.targetY - follower.currentY) * lerp * delta;

      // Update position
      follower.graphics.position.set(follower.currentX, follower.currentY);

      // Pulse effect for active followers
      const pulse = 1 + Math.sin(Date.now() / 200) * 0.1;
      follower.graphics.scale.set(pulse);

      // Spawn trail particles
      if (this.frameCount % this.TRAIL_SPAWN_RATE === 0) {
        this.spawnTrailParticle(follower);
      }

      // Update trail particles
      this.updateTrail(follower);
    });
  }

  /**
   * Spawn a new trail particle at follower's current position
   */
  private spawnTrailParticle(follower: MouseFollowerData) {
    // Create trail particle graphics
    const particle = new PIXI.Graphics();
    const radius = 12;
    particle.beginFill(follower.color, 0.6);
    particle.drawCircle(0, 0, radius);
    particle.endFill();
    particle.position.set(follower.currentX, follower.currentY);
    particle.zIndex = 999; // Just below the main follower

    this.stage.addChild(particle);

    // Add to trail array
    follower.trail.push({
      x: follower.currentX,
      y: follower.currentY,
      alpha: 0.6,
      radius,
      graphics: particle,
    });

    // Limit trail length
    if (follower.trail.length > this.TRAIL_LENGTH) {
      const oldParticle = follower.trail.shift();
      if (oldParticle && oldParticle.graphics) {
        this.stage.removeChild(oldParticle.graphics);
        oldParticle.graphics.destroy();
      }
    }
  }

  /**
   * Update trail particles (fade out and shrink)
   */
  private updateTrail(follower: MouseFollowerData) {
    follower.trail.forEach((particle, index) => {
      // Fade out based on position in trail (older = more faded)
      const fadeFactor = 1 - (index / this.TRAIL_LENGTH);
      particle.alpha = 0.6 * fadeFactor;

      // Shrink radius
      const newRadius = particle.radius * fadeFactor;

      // Update graphics
      particle.graphics.clear();
      particle.graphics.beginFill(follower.color, particle.alpha);
      particle.graphics.drawCircle(0, 0, newRadius);
      particle.graphics.endFill();
    });
  }

  /**
   * Get current follower count
   */
  getFollowerCount(): number {
    return this.followers.size;
  }

  /**
   * Clear all followers (on room leave)
   */
  destroy() {
    this.followers.forEach((follower) => {
      if (follower.graphics) {
        this.stage.removeChild(follower.graphics);
      }
      // Clean up trail particles
      follower.trail.forEach((particle) => {
        if (particle.graphics) {
          this.stage.removeChild(particle.graphics);
          particle.graphics.destroy();
        }
      });
      follower.trail = [];
    });
    this.followers.clear();
    console.log('[MouseFollowerManager] Destroyed');
  }
}

================================================================================
Ğ¤ĞĞ™Ğ› 2: client/src/main.ts
================================================================================

import { GameEngine } from './core/GameEngine';
import { NetworkManager } from './core/NetworkManager';
import { InputManager } from './core/InputManager';
import { UIController } from './ui/UIController';
import { ChatManager } from './chat/ChatManager';
import { MouseFollowerManager } from './features/mouse-follower/MouseFollowerManager';
import { DraggableObject } from './features/draggable/DraggableObject';
import { DraggableChatManager } from './chat/DraggableChatManager';

console.log('[MainApp] main.ts loaded');

class MainApp {
  private gameEngine!: GameEngine;
  private networkManager!: NetworkManager;
  private inputManager!: InputManager;
  private uiController!: UIController;
  private chatManager!: ChatManager;
  private mouseFollower!: MouseFollowerManager;
  private draggableObject!: DraggableObject;
  private draggableChat!: DraggableChatManager;

  constructor() {
    console.log('[MainApp] Constructor started...');

    try {
      console.log('[MainApp] Creating GameEngine...');
      this.gameEngine = new GameEngine();
      console.log('[MainApp] Creating NetworkManager...');
      this.networkManager = new NetworkManager();
      console.log('[MainApp] Creating InputManager...');
      this.inputManager = new InputManager();
      console.log('[MainApp] Creating UIController...');
      this.uiController = new UIController();
      console.log('[MainApp] Creating ChatManager...');
      this.chatManager = new ChatManager();
      console.log('[MainApp] Creating DraggableChatManager...');
      this.draggableChat = new DraggableChatManager(this.networkManager);

      console.log('[MainApp] Setting up interactions...');
      this.setupInteractions();

      // Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ PixiJS (Ğ°ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ğ¾) â€” Ğ¿Ğ¾Ñ‚Ğ¾Ğ¼ ÑĞ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ mouse follower
      console.log('[MainApp] Initializing GameEngine...');
      this.gameEngine.init('canvasContainer').then(() => {
        console.log('[MainApp] GameEngine initialized!');

        // Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ MouseFollowerManager ĞŸĞĞ¡Ğ›Ğ• Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ PixiJS
        console.log('[MainApp] Creating MouseFollowerManager...');
        this.mouseFollower = new MouseFollowerManager(this.gameEngine.app!.stage, this.networkManager);

        // Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ DraggableObject Ğ² Ñ†ĞµĞ½Ñ‚Ñ€Ğµ ÑĞºÑ€Ğ°Ğ½Ğ°
        console.log('[MainApp] Creating DraggableObject...');
        this.draggableObject = new DraggableObject(this.gameEngine.app!.stage, this.networkManager);
        this.draggableObject.init(window.innerWidth, window.innerHeight);

        // ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡Ğ°ĞµĞ¼ InputManager Ğº MouseFollowerManager
        this.inputManager.onMouseMove = (x, y) => {
          this.mouseFollower.updateLocalPosition(x, y);
        };

        console.log('[MainApp] Mouse follower and draggable object initialized!');
        this.gameEngine.start();
      }).catch((error) => {
        console.error('[MainApp] GameEngine init ERROR:', error);
      });

      console.log('[MainApp] Constructor finished!');
    } catch (error) {
      console.error('[MainApp] Constructor ERROR:', error);
    }
  }

  private setupInteractions(): void {
    console.log('[MainApp] Setting up interactions...');

    this.uiController.onCreateRoom = async () => {
      console.log('[MainApp] onCreateRoom called!');
      try {
        console.log('[MainApp] Calling networkManager.createRoom()...');
        const roomId = await this.networkManager.createRoom();
        console.log('[MainApp] Room created with ID:', roomId);

        // Ğ–Ğ´Ñ‘Ğ¼ ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ³Ğ¾ Ñ‚Ğ¸ĞºĞ°, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ DOM Ğ±Ñ‹Ğ» Ğ³Ğ¾Ñ‚Ğ¾Ğ²
        await new Promise(resolve => setTimeout(resolve, 0));

        console.log('[MainApp] Calling setView(room)...');
        this.uiController.setView('room');
        console.log('[MainApp] setView(room) completed');

        // ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ ID ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ñ‹ ÑÑ€Ğ°Ğ·Ñƒ
        this.uiController.showCreatedRoomId(roomId);

        const room = this.networkManager.getCurrentRoom();
        if (room) {
          this.chatManager.attachToRoom(room);
          // Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ mouse follower Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ĞµĞ»Ñ
          this.mouseFollower.onRoomJoined(true, this.networkManager.getSessionId()!);
          // Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµĞ¼ draggable chat
          this.draggableChat.init();
        }
        this.uiController.setPlayerName('Player 1');
      } catch (error) {
        console.error('[MainApp] ERROR in onCreateRoom:', error);
        alert('Create room ERROR: ' + error);
      }
    };

    this.uiController.onJoinRoom = async (roomId) => {
      console.log('[MainApp] onJoinRoom called with roomId:', roomId);
      try {
        await this.networkManager.joinRoom(roomId);
        console.log('[MainApp] Joined room successfully');

        // Ğ–Ğ´Ñ‘Ğ¼ ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ³Ğ¾ Ñ‚Ğ¸ĞºĞ°, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ DOM Ğ±Ñ‹Ğ» Ğ³Ğ¾Ñ‚Ğ¾Ğ²
        await new Promise(resolve => setTimeout(resolve, 0));

        console.log('[MainApp] Calling setView(room)...');
        this.uiController.setView('room');
        console.log('[MainApp] setView(room) completed');

        // ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ ID ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ñ‹ ÑÑ€Ğ°Ğ·Ñƒ
        this.uiController.showCreatedRoomId(roomId);

        const room = this.networkManager.getCurrentRoom();
        if (room) {
          this.chatManager.attachToRoom(room);
          // Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ mouse follower Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½Ğ¸Ğ²ÑˆĞµĞ³Ğ¾ÑÑ
          this.mouseFollower.onRoomJoined(false, this.networkManager.getSessionId()!);
          // Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµĞ¼ draggable chat
          this.draggableChat.init();
        }
        this.uiController.setPlayerName('Player 2');
      } catch (error) {
        console.error('[MainApp] ERROR in onJoinRoom:', error);
        alert('Join room ERROR: ' + error);
      }
    };
  }
}

// Ğ—Ğ°Ğ¿ÑƒÑĞº Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ¿Ñ€Ğ¸ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞµ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ñ‹
console.log('[MainApp] Registering load event listener...');

window.addEventListener('load', () => {
  console.log('[MainApp] LOAD EVENT FIRED');
  console.log('Creating new MainApp()...');
  new MainApp();
  console.log('MainApp() created!');
});

console.log('[MainApp] Load event listener registered');

================================================================================
Ğ¤ĞĞ™Ğ› 3: client/src/core/InputManager.ts
================================================================================

/**
 * ĞœĞµĞ½ĞµĞ´Ğ¶ĞµÑ€ Ğ²Ğ²Ğ¾Ğ´Ğ°
 * ĞĞ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµÑ‚ ĞºĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ñƒ Ğ¸ Ğ¼Ñ‹ÑˆÑŒ
 */
export class InputManager {
  private keyboardState: Map<string, boolean>;
  private mouseState: {
    x: number;
    y: number;
    leftButton: boolean;
    rightButton: boolean;
  };

  // Callback Ğ´Ğ»Ñ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ¼Ñ‹ÑˆĞ¸ (Ğ´Ğ»Ñ follower circle)
  public onMouseMove?: (x: number, y: number) => void;

  constructor() {
    this.keyboardState = new Map();
    this.mouseState = {
      x: 0,
      y: 0,
      leftButton: false,
      rightButton: false
    };

    this.setupEventListeners();
  }

  /**
   * Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸ĞºĞ¸ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ğ¹
   */
  private setupEventListeners(): void {
    // Keyboard events
    window.addEventListener('keydown', (e) => {
      this.keyboardState.set(e.code, true);
    });

    window.addEventListener('keyup', (e) => {
      this.keyboardState.set(e.code, false);
    });

    // Mouse events
    window.addEventListener('mousemove', (e) => {
      // Mouse position relative to viewport (canvas is full screen at 0,0)
      this.mouseState.x = e.clientX;
      this.mouseState.y = e.clientY;

      // Ğ’Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ callback Ğ´Ğ»Ñ follower circle
      if (this.onMouseMove) {
        this.onMouseMove(this.mouseState.x, this.mouseState.y);
      }
    });

    window.addEventListener('mousedown', (e) => {
      switch (e.button) {
        case 0: // Left button
          this.mouseState.leftButton = true;
          break;
        case 2: // Right button
          this.mouseState.rightButton = true;
          break;
      }
    });

    window.addEventListener('mouseup', (e) => {
      switch (e.button) {
        case 0: // Left button
          this.mouseState.leftButton = false;
          break;
        case 2: // Right button
          this.mouseState.rightButton = false;
          break;
      }
    });

    // Prevent context menu on right click
    window.addEventListener('contextmenu', (e) => {
      e.preventDefault();
    });
  }

  /**
   * ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ, Ğ½Ğ°Ğ¶Ğ°Ñ‚Ğ° Ğ»Ğ¸ ĞºĞ»Ğ°Ğ²Ğ¸ÑˆĞ°
   */
  isKeyPressed(keyCode: string): boolean {
    return this.keyboardState.get(keyCode) === true;
  }

  /**
   * ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ¼Ñ‹ÑˆĞ¸
   */
  getMouseState(): { x: number; y: number; leftButton: boolean; rightButton: boolean } {
    return { ...this.mouseState };
  }

  /**
   * ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ¼Ñ‹ÑˆĞ¸
   */
  getMousePosition(): { x: number; y: number } {
    return { x: this.mouseState.x, y: this.mouseState.y };
  }
}

================================================================================
Ğ¤ĞĞ™Ğ› 4: client/src/core/GameEngine.ts
================================================================================

import * as PIXI from 'pixi.js';

/**
 * Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹ Ğ¸Ğ³Ñ€Ğ¾Ğ²Ğ¾Ğ¹ Ğ´Ğ²Ğ¸Ğ¶Ğ¾Ğº
 * Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ñ€ĞµĞ½Ğ´ĞµÑ€ + ticker, Ğ±ĞµĞ· Ğ»Ğ¾Ğ³Ğ¸ĞºĞ¸
 */
export class GameEngine {
  app: PIXI.Application | null = null;
  private ticker: PIXI.Ticker | null = null;

  constructor() {
    console.log('[GameEngine] Constructor called');
  }

  /**
   * Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ PixiJS (Ğ°ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ğ¾)
   */
  async init(containerId: string): Promise<void> {
    console.log('[GameEngine] Initializing PixiJS...');

    const container = document.getElementById(containerId);
    if (!container) {
      throw new Error(`Container element with id "${containerId}" not found`);
    }

    // Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ğ¸ Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ
    this.app = new PIXI.Application();

    await this.app.init({
      backgroundColor: 0x1a1a1a,
      width: window.innerWidth,
      height: window.innerHeight,
      antialias: true,
      autoDensity: true,
      resolution: Math.min(window.devicePixelRatio, 2),
    });

    console.log('[GameEngine] PixiJS initialized, getting ticker...');

    // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ticker Ğ¿Ğ¾ÑĞ»Ğµ Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸
    this.ticker = this.app.ticker;

    // ĞšĞ Ğ˜Ğ¢Ğ˜Ğ§Ğ•Ğ¡ĞšĞĞ¯ Ğ¡Ğ¢Ğ ĞĞšĞ â€” Ğ¾Ñ‚ĞºĞ»ÑÑ‡Ğ°ĞµĞ¼ pointer events Ğ½Ğ° canvas
    this.app.canvas.style.pointerEvents = 'none';

    console.log('[GameEngine] Appending canvas...');
    // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ canvas Ğ² ĞºĞ¾Ğ½Ñ‚ĞµĞ¹Ğ½ĞµÑ€
    container.appendChild(this.app.canvas);

    console.log('[GameEngine] Canvas appended');
  }

  /**
   * Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ½Ğ° Ñ‚Ğ¸ĞºĞµÑ€
   */
  addTickerUpdate(updateFn: (dt: number) => void): void {
    if (this.ticker) {
      this.ticker.add((ticker) => {
        const dt = ticker.deltaTime;
        updateFn(dt);
      });
    } else {
      console.error('[GameEngine] Ticker is null!');
    }
  }

  /**
   * Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ Ñ‚Ğ¸ĞºĞµÑ€
   */
  start(): void {
    if (this.ticker) {
      this.ticker.start();
      console.log('[GameEngine] Ticker started');
    } else {
      console.error('[GameEngine] Cannot start: ticker is null');
    }
  }

  /**
   * ĞÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ñ‚Ğ¸ĞºĞµÑ€
   */
  stop(): void {
    if (this.ticker) {
      this.ticker.stop();
    }
  }
}

================================================================================
Ğ¤ĞĞ™Ğ› 5: client/src/core/NetworkManager.ts
================================================================================

import { Client } from 'colyseus.js';
import { Room } from 'colyseus.js';

/**
 * ĞœĞµĞ½ĞµĞ´Ğ¶ĞµÑ€ ÑĞµÑ‚ĞµĞ²Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ
 * Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸ĞµĞ¼ Ğº Colyseus ÑĞµÑ€Ğ²ĞµÑ€Ñƒ
 */
export class NetworkManager {
  private client: Client;
  private currentRoom: Room | null = null;
  private readonly serverUrl: string;

  constructor(serverUrl?: string) {
    // Ğ›Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ÑĞµÑ€Ğ²ĞµÑ€ Ğ´Ğ»Ñ Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸, Ğ¿Ñ€Ğ¾Ğ´-ÑĞµÑ€Ğ²ĞµÑ€ Ğ´Ğ»Ñ production
    const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
    this.serverUrl = serverUrl || (isLocalhost ? 'ws://localhost:2567' : 'wss://cursor-hold-game-server.onrender.com');
    this.client = new Client(this.serverUrl);

    console.log('[NetworkManager] Server URL:', this.serverUrl);
  }

  /**
   * ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒÑÑ Ğº ÑĞµÑ€Ğ²ĞµÑ€Ñƒ
   */
  async connect(): Promise<void> {
    try {
      // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ
      await this.client.joinOrCreate('holding_room'); // Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğµ Ğ¸Ğ¼Ñ ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ñ‹
      console.log('Connected to server:', this.serverUrl);
    } catch (error) {
      console.error('Failed to connect to server:', error);
      throw error;
    }
  }

  /**
   * Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²ÑƒÑ ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ñƒ
   * Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ID ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ñ‹ Ğ¾Ñ‚ Colyseus
   */
  async createRoom(): Promise<string> {
    console.log('[NetworkManager] createRoom() called');
    try {
      console.log('[NetworkManager] Calling client.joinOrCreate("holding_room")...');
      // Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ğ½Ğ¾Ğ²ÑƒÑ ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ñƒ Ñ‡ĞµÑ€ĞµĞ· joinOrCreate
      this.currentRoom = await this.client.joinOrCreate('holding_room');
      console.log('[NetworkManager] Room object received:', this.currentRoom);

      // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ roomId Ğ¸Ğ· state ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ñ‹
      const roomId = this.currentRoom.state?.roomId || this.currentRoom.id;
      console.log('[NetworkManager] Room created:', roomId);

      // ĞŸĞ¾Ğ´Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµĞ¼ÑÑ Ğ½Ğ° ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ñ‹ Ğ¿Ğ¾ÑĞ»Ğµ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ
      this.setupRoomMessageHandlers();

      return roomId;
    } catch (error: unknown) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      console.error('[NetworkManager] ERROR in createRoom:', errorMsg);
      alert('Failed to create room: ' + errorMsg + '\\n\\nMake sure the server is running on port 2567.');
      throw error;
    }
  }

  /**
   * ĞŸÑ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½Ğ¸Ñ‚ÑŒÑÑ Ğº ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰ĞµĞ¹ ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ğµ Ğ¿Ğ¾ ID
   */
  async joinRoom(roomId: string): Promise<Room> {
    console.log('[NetworkManager] joinRoom() called with roomId:', roomId);
    try {
      // ĞŸÑ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½ÑĞµĞ¼ÑÑ Ğº ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ğµ Ğ¿Ğ¾ ID Ñ‡ĞµÑ€ĞµĞ· joinById
      this.currentRoom = await this.client.joinById(roomId);
      console.log('[NetworkManager] Joined room:', this.currentRoom.id);

      // ĞŸĞ¾Ğ´Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµĞ¼ÑÑ Ğ½Ğ° ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ñ‹ Ğ¿Ğ¾ÑĞ»Ğµ Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ
      this.setupRoomMessageHandlers();

      return this.currentRoom;
    } catch (error: unknown) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      console.error('[NetworkManager] ERROR in joinRoom:', errorMsg);
      alert('Failed to join room: ' + errorMsg + '\\n\\nCheck the room ID and make sure the server is running.');
      throw error;
    }
  }

  /**
   * ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚ (Ğ´Ğ»Ñ Ğ±ÑƒĞ´ÑƒÑ‰ĞµĞ³Ğ¾ UI)
   */
  async getAvailableRooms(): Promise<any[]> {
    try {
      const rooms = await this.client.getAvailableRooms('holding_room');
      return rooms;
    } catch (error) {
      console.error('Failed to get available rooms:', error);
      return [];
    }
  }

  /**
   * ĞŸĞ¾ĞºĞ¸Ğ½ÑƒÑ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ñƒ
   */
  leaveCurrentRoom(): void {
    if (this.currentRoom) {
      this.currentRoom.leave();
      this.currentRoom = null;
    }
  }

  /**
   * ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ñƒ
   */
  getCurrentRoom(): Room | null {
    return this.currentRoom;
  }

  /**
   * ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ² ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ñƒ
   */
  sendToRoom(messageType: string, data: any): void {
    if (this.currentRoom) {
      this.currentRoom.send(messageType, data);
    } else {
      console.warn('No active room to send message to');
    }
  }

  /**
   * ĞŸĞ¾Ğ´Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ Ğ½Ğ° ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ¸Ğ· ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ñ‹
   */
  onMessage(messageType: string, callback: (data: any) => void): void {
    if (this.currentRoom) {
      this.currentRoom.onMessage(messageType, (data) => {
        callback(data);
      });
    } else {
      console.warn('No active room to listen to messages from');
    }
  }

  /**
   * ĞŸĞ¾Ğ´Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ Ğ½Ğ° Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ñ‹
   */
  onStateChange(callback: (state: any) => void): void {
    if (this.currentRoom) {
      this.currentRoom.onStateChange((state) => {
        callback(state);
      });
    } else {
      console.warn('No active room to listen to state changes from');
    }
  }

  /**
   * ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰ĞµĞµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ñ‹
   */
  getState() {
    if (this.currentRoom) {
      return this.currentRoom.state;
    }
    return null;
  }

  /**
   * ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ sessionId Ñ‚ĞµĞºÑƒÑ‰ĞµĞ¹ ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ñ‹
   */
  getSessionId(): string | null {
    return this.currentRoom?.sessionId || null;
  }

  /**
   * ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¸Ñ‚ÑŒ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸ĞºĞ¸ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹ ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ñ‹
   */
  private setupRoomMessageHandlers(): void {
    if (!this.currentRoom) return;

    console.log('[NetworkManager] setupRoomMessageHandlers called, sessionId:', this.currentRoom.sessionId);
  }

  /**
   * ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ ĞºÑƒÑ€ÑĞ¾Ñ€Ğ°
   */
  sendCursorUpdate(x: number, y: number): void {
    if (this.currentRoom) {
      this.currentRoom.send('updateCursor', { x, y });
    }
  }
}

================================================================================
Ğ¤ĞĞ™Ğ› 6: server/src/rooms/HoldingRoom.ts (MFL ÑĞµĞºÑ†Ğ¸Ñ)
================================================================================

// Handle mouse follower updates (MFL system - broadcasts to ALL including sender)
this.onMessage('mflUpdate', (client, data) => {
  if (typeof data.x === 'number' && typeof data.y === 'number' && typeof data.isCreator === 'boolean') {
    // Get player to verify isCreator status
    const player = this.state.players.get(client.sessionId);
    if (player) {
      // Broadcast to ALL players (including sender) so everyone sees both followers
      this.broadcast('mflUpdate', {
        playerId: client.sessionId,
        isCreator: data.isCreator,
        x: data.x,
        y: data.y
      });
    }
  }
});

================================================================================
Ğ¤ĞĞ™Ğ› 7: server/src/rooms/schema.ts
================================================================================

import { Schema, type, MapSchema } from '@colyseus/schema';

export class PlayerSchema extends Schema {
  @type('string') id!: string;
  @type('string') name: string = '';
  @type('number') x: number = 0;
  @type('number') y: number = 0;
  @type('number') color: number = 0xffffff; // Default white color
  @type('boolean') isHoldingHands: boolean = false;
  @type('string') holdingHandsWith: string = ''; // ID of player this player is holding hands with
  @type('boolean') isRoomCreator: boolean = false; // Whether this player created the room
  @type('boolean') isReady: boolean = false; // Whether the player is ready to start the virus battle
  @type({ map: 'number' }) virusParams: Map<string, number> = new Map<string, number>(); // Virus parameters for the player
  @type('number') cursorX: number = 0; // Cursor X position for the player
  @type('number') cursorY: number = 0; // Cursor Y position for the player
}

export class DraggableObjectSchema extends Schema {
  @type('string') id!: string;
  @type('number') x: number = 400; // Center of screen
  @type('number') y: number = 300;
  @type('number') radius: number = 30;
  @type('number') color: number = 0xff69b4; // Hot pink color
  @type('boolean') isBeingDragged: boolean = false;
  @type('string') draggedBy: string = ''; // ID of player dragging the object
  @type('boolean') isFollower: boolean = false; // Whether this object is a follower
  @type('string') owner: string = ''; // ID of the player who owns this follower
  @type('number') targetX: number = 0; // Target position for followers
  @type('number') targetY: number = 0; // Target position for followers
}

export class RoomState extends Schema {
  @type({ map: PlayerSchema }) players = new MapSchema<PlayerSchema>();
  @type({ map: DraggableObjectSchema }) objects = new MapSchema<DraggableObjectSchema>();
  @type('string') roomId: string = '';
  @type('number') maxPlayers: number = 2;
  @type({ array: 'number' }) battleGrid: number[] = []; // Array representing the battle grid state (0=empty, 1=virusA, 2=virusB)
  @type('boolean') battleActive: boolean = false; // Whether the battle is currently active
}

================================================================================
Ğ¤ĞĞ™Ğ› 8: client/index.html (CSS Ğ´Ğ»Ñ canvasContainer)
================================================================================

#canvasContainer {
  position: absolute;
  top: 0;
  left: 0; /* Full screen - starts at left edge */
  width: 100%; /* Full width */
  height: 100%;
  z-index: 1; /* Below the grid */
  pointer-events: none;
}

================================================================================
ĞĞ Ğ¥Ğ˜Ğ¢Ğ•ĞšĞ¢Ğ£Ğ Ğ MFL SYSTEM
================================================================================

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         PLAYER 1 SCREEN                         â”‚
â”‚                                                                 â”‚
â”‚   ğŸ”´ mfl1 (ÑĞ»ĞµĞ´ÑƒĞµÑ‚ Ğ·Ğ° Ğ¼Ñ‹ÑˆÑŒÑ P1)                                 â”‚
â”‚                                                                 â”‚
â”‚   ğŸ”µ mfl2 (ÑĞ»ĞµĞ´ÑƒĞµÑ‚ Ğ·Ğ° Ğ¼Ñ‹ÑˆÑŒÑ P2)                                 â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         PLAYER 2 SCREEN                         â”‚
â”‚                                                                 â”‚
â”‚   ğŸ”´ mfl1 (ÑĞ»ĞµĞ´ÑƒĞµÑ‚ Ğ·Ğ° Ğ¼Ñ‹ÑˆÑŒÑ P1)                                 â”‚
â”‚                                                                 â”‚
â”‚   ğŸ”µ mfl2 (ÑĞ»ĞµĞ´ÑƒĞµÑ‚ Ğ·Ğ° Ğ¼Ñ‹ÑˆÑŒÑ P2)                                 â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ĞĞ‘Ğ Ğ¸Ğ³Ñ€Ğ¾ĞºĞ° Ğ²Ğ¸Ğ´ÑÑ‚ ĞĞ”Ğ˜ĞĞĞšĞĞ’Ğ«Ğ• followers Ğ½Ğ° ÑĞ²Ğ¾Ğ¸Ñ… ÑĞºÑ€Ğ°Ğ½Ğ°Ñ…!

================================================================================
Ğ¡Ğ•Ğ¢Ğ¬
================================================================================

Client (Mouse Input)
    â†“
InputManager.onMouseMove(x, y)
    â†“
MouseFollowerManager.updateLocalPosition(x, y)
    â†“
NetworkManager.sendToRoom('mflUpdate', { isCreator, x, y })
    â†“
WebSocket â†’ Server
    â†“
HoldingRoom.onMessage('mflUpdate')
    â†“
Broadcast to ALL clients: 'mflUpdate' { playerId, isCreator, x, y }
    â†“
Client receives 'mflUpdate'
    â†“
MouseFollowerManager.updateRemoteFollower()
    â†“
PixiJS renders follower at interpolated position

================================================================================
ĞšĞ›Ğ®Ğ§Ğ•Ğ’Ğ«Ğ• ĞŸĞĞ ĞĞœĞ•Ğ¢Ğ Ğ«
================================================================================

MouseFollowerManager.ts:
  - SEND_INTERVAL_MS: 33         (~30 updates/sec)
  - TRAIL_LENGTH: 8              (8 trail particles)
  - TRAIL_SPAWN_RATE: 3          (spawn every 3 frames)
  - lerp: 0.2                    (smooth interpolation)
  - Follower radius: 20px
  - Trail radius: 12px
  - mfl1 color: 0xff0000 (RED)
  - mfl2 color: 0x0000ff (BLUE)

================================================================================
ĞšĞĞĞ•Ğ¦ Ğ¤ĞĞ™Ğ›Ğ
================================================================================
